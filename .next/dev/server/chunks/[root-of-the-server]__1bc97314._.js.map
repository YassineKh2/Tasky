{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 46, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/yassine/Downloads/Task%20Tracker%20App/lib/prisma.ts"],"sourcesContent":["import { PrismaClient } from \"@prisma/client\";\r\n\r\ndeclare global {\r\n  var prisma: PrismaClient | undefined;\r\n}\r\n\r\nexport const prisma =\r\n  global.prisma ||\r\n  new PrismaClient({\r\n    log: [\"error\"],\r\n  });\r\n\r\nif (process.env.NODE_ENV !== \"production\") {\r\n  global.prisma = prisma;\r\n}\r\n\r\nexport default prisma;\r\n"],"names":[],"mappings":";;;;;;AAAA;;AAMO,MAAM,SACX,OAAO,MAAM,IACb,IAAI,sMAAY,CAAC;IACf,KAAK;QAAC;KAAQ;AAChB;AAEF,wCAA2C;IACzC,OAAO,MAAM,GAAG;AAClB;uCAEe"}},
    {"offset": {"line": 67, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/yassine/Downloads/Task%20Tracker%20App/lib/db.ts"],"sourcesContent":["import { prisma } from \"./prisma\";\r\n\r\n/**\r\n * Task Definition utilities\r\n */\r\nexport const taskDefinitionService = {\r\n  // Get all task definitions\r\n  async getAll() {\r\n    return await prisma.taskDefinition.findMany({\r\n      orderBy: {\r\n        createdAt: \"desc\",\r\n      },\r\n    });\r\n  },\r\n\r\n  // Get a single task definition\r\n  async getById(id: string) {\r\n    return await prisma.taskDefinition.findUnique({\r\n      where: { id },\r\n      include: {\r\n        assignments: true,\r\n        trackingHistory: true,\r\n      },\r\n    });\r\n  },\r\n\r\n  // Create a new task definition\r\n  async create(data: {\r\n    text: string;\r\n    description?: string;\r\n    baselineDuration: number;\r\n    isRecurring: boolean;\r\n    recurringDays: number[];\r\n  }) {\r\n    return await prisma.taskDefinition.create({\r\n      data: {\r\n        text: data.text,\r\n        description: data.description,\r\n        baselineDuration: data.baselineDuration,\r\n        isRecurring: data.isRecurring,\r\n        recurringDays: JSON.stringify(data.recurringDays),\r\n      },\r\n    });\r\n  },\r\n\r\n  // Update a task definition\r\n  async update(\r\n    id: string,\r\n    data: Partial<{\r\n      text: string;\r\n      description?: string;\r\n      baselineDuration: number;\r\n      isRecurring: boolean;\r\n      recurringDays: number[];\r\n    }>,\r\n  ) {\r\n    const updateData: any = { ...data };\r\n    if (data.recurringDays) {\r\n      updateData.recurringDays = JSON.stringify(data.recurringDays);\r\n    }\r\n    return await prisma.taskDefinition.update({\r\n      where: { id },\r\n      data: updateData,\r\n    });\r\n  },\r\n\r\n  // Delete a task definition\r\n  async delete(id: string) {\r\n    return await prisma.taskDefinition.delete({\r\n      where: { id },\r\n    });\r\n  },\r\n};\r\n\r\n/**\r\n * Task Assignment utilities\r\n */\r\nexport const taskAssignmentService = {\r\n  // Get all assignments for a date range\r\n  async getByDateRange(startDate: string, endDate: string) {\r\n    return await prisma.taskAssignment.findMany({\r\n      where: {\r\n        dateStr: {\r\n          gte: startDate,\r\n          lte: endDate,\r\n        },\r\n      },\r\n      include: {\r\n        task: true,\r\n      },\r\n      orderBy: {\r\n        dateStr: \"asc\",\r\n      },\r\n    });\r\n  },\r\n\r\n  // Get assignments for a specific date\r\n  async getByDate(dateStr: string) {\r\n    return await prisma.taskAssignment.findMany({\r\n      where: { dateStr },\r\n      include: { task: true },\r\n      orderBy: { createdAt: \"asc\" },\r\n    });\r\n  },\r\n\r\n  // Get all assignments for a task\r\n  async getByTaskId(taskId: string) {\r\n    return await prisma.taskAssignment.findMany({\r\n      where: { taskId },\r\n      orderBy: { dateStr: \"desc\" },\r\n    });\r\n  },\r\n\r\n  // Create a new assignment\r\n  async create(data: {\r\n    taskId: string;\r\n    dateStr: string;\r\n    durationOverride?: number;\r\n    loggedHours?: number;\r\n    completed?: boolean;\r\n  }) {\r\n    return await prisma.taskAssignment.create({\r\n      data: {\r\n        taskId: data.taskId,\r\n        dateStr: data.dateStr,\r\n        durationOverride: data.durationOverride,\r\n        loggedHours: data.loggedHours || 0,\r\n        completed: data.completed ?? false,\r\n      },\r\n    });\r\n  },\r\n\r\n  // Update an assignment\r\n  async update(\r\n    id: string,\r\n    data: Partial<{\r\n      durationOverride?: number;\r\n      completed: boolean;\r\n      loggedHours: number;\r\n    }>,\r\n  ) {\r\n    return await prisma.taskAssignment.update({\r\n      where: { id },\r\n      data,\r\n    });\r\n  },\r\n\r\n  // Delete an assignment\r\n  async delete(id: string) {\r\n    return await prisma.taskAssignment.delete({\r\n      where: { id },\r\n    });\r\n  },\r\n};\r\n\r\n/**\r\n * Day Off utilities\r\n */\r\nexport const dayOffService = {\r\n  // Get all days off in a date range\r\n  async getByDateRange(startDate: string, endDate: string) {\r\n    return await prisma.dayOff.findMany({\r\n      where: {\r\n        dateStr: {\r\n          gte: startDate,\r\n          lte: endDate,\r\n        },\r\n      },\r\n    });\r\n  },\r\n\r\n  // Check if a date is a day off\r\n  async isDateOff(dateStr: string) {\r\n    const dayOff = await prisma.dayOff.findUnique({\r\n      where: { dateStr },\r\n    });\r\n    return !!dayOff;\r\n  },\r\n\r\n  // Mark a day as off\r\n  async markAsOff(dateStr: string) {\r\n    return await prisma.dayOff.upsert({\r\n      where: { dateStr },\r\n      update: {},\r\n      create: { dateStr },\r\n    });\r\n  },\r\n\r\n  // Unmark a day as off\r\n  async unmarkAsOff(dateStr: string) {\r\n    return await prisma.dayOff\r\n      .delete({\r\n        where: { dateStr },\r\n      })\r\n      .catch(() => null); // Return null if not found\r\n  },\r\n};\r\n\r\n/**\r\n * Task Tracking utilities\r\n */\r\nexport const taskTrackingService = {\r\n  // Get tracking history for a task\r\n  async getByTaskId(taskId: string) {\r\n    return await prisma.taskTracking.findMany({\r\n      where: { taskId },\r\n      orderBy: { createdAt: \"desc\" },\r\n    });\r\n  },\r\n\r\n  // Get tracking history for an assignment\r\n  async getByAssignmentId(assignmentId: string) {\r\n    return await prisma.taskTracking.findMany({\r\n      where: { assignmentId },\r\n      orderBy: { createdAt: \"desc\" },\r\n    });\r\n  },\r\n\r\n  // Create tracking record\r\n  async create(data: {\r\n    assignmentId: string;\r\n    taskId: string;\r\n    hoursLogged: number;\r\n    dayCompleted?: boolean;\r\n    totalHours?: number;\r\n    recurringDays?: number[];\r\n  }) {\r\n    return await prisma.taskTracking.create({\r\n      data: {\r\n        assignmentId: data.assignmentId,\r\n        taskId: data.taskId,\r\n        hoursLogged: data.hoursLogged,\r\n        dayCompleted: data.dayCompleted || false,\r\n        totalHours: data.totalHours || 0,\r\n        recurringDays: data.recurringDays\r\n          ? JSON.stringify(data.recurringDays)\r\n          : null,\r\n        completionDate: data.dayCompleted ? new Date() : null,\r\n      },\r\n    });\r\n  },\r\n\r\n  // Update tracking record\r\n  async update(\r\n    id: string,\r\n    data: Partial<{\r\n      hoursLogged: number;\r\n      dayCompleted: boolean;\r\n      totalHours: number;\r\n    }>,\r\n  ) {\r\n    return await prisma.taskTracking.update({\r\n      where: { id },\r\n      data: {\r\n        ...data,\r\n        completionDate: data.dayCompleted ? new Date() : undefined,\r\n      },\r\n    });\r\n  },\r\n\r\n  // Get aggregated statistics for a task\r\n  async getTaskStats(taskId: string) {\r\n    const tracking = await prisma.taskTracking.findMany({\r\n      where: { taskId },\r\n    });\r\n\r\n    const totalHours = tracking.reduce((sum, t) => sum + t.hoursLogged, 0);\r\n    const daysCompleted = tracking.filter((t) => t.dayCompleted).length;\r\n    const totalInstances = tracking.length;\r\n\r\n    return {\r\n      taskId,\r\n      totalHours,\r\n      daysCompleted,\r\n      totalInstances,\r\n      averageHoursPerDay: totalInstances > 0 ? totalHours / totalInstances : 0,\r\n    };\r\n  },\r\n};\r\n"],"names":[],"mappings":"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"}},
    {"offset": {"line": 323, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/yassine/Downloads/Task%20Tracker%20App/app/api/days-off/%5BdateStr%5D/route.ts"],"sourcesContent":["import { NextResponse } from \"next/server\";\r\nimport { dayOffService } from \"@/lib/db\";\r\n\r\n/**\r\n * DELETE /api/days-off/[dateStr]\r\n * Unmark a day as off\r\n */\r\nexport async function DELETE(\r\n  _request: Request,\r\n  { params }: { params: Promise<{ dateStr: string }> },\r\n) {\r\n  try {\r\n    const { dateStr } = await params;\r\n    const result = await dayOffService.unmarkAsOff(dateStr);\r\n\r\n    if (!result) {\r\n      return NextResponse.json({ error: \"Day off not found\" }, { status: 404 });\r\n    }\r\n\r\n    return NextResponse.json({ message: \"Day off removed successfully\" });\r\n  } catch (error) {\r\n    console.error(\"Error removing day off:\", error);\r\n    return NextResponse.json(\r\n      { error: \"Failed to remove day off\" },\r\n      { status: 500 },\r\n    );\r\n  }\r\n}\r\n"],"names":[],"mappings":";;;;AAAA;AACA;;;AAMO,eAAe,OACpB,QAAiB,EACjB,EAAE,MAAM,EAA4C;IAEpD,IAAI;QACF,MAAM,EAAE,OAAO,EAAE,GAAG,MAAM;QAC1B,MAAM,SAAS,MAAM,4HAAa,CAAC,WAAW,CAAC;QAE/C,IAAI,CAAC,QAAQ;YACX,OAAO,gJAAY,CAAC,IAAI,CAAC;gBAAE,OAAO;YAAoB,GAAG;gBAAE,QAAQ;YAAI;QACzE;QAEA,OAAO,gJAAY,CAAC,IAAI,CAAC;YAAE,SAAS;QAA+B;IACrE,EAAE,OAAO,OAAO;QACd,QAAQ,KAAK,CAAC,2BAA2B;QACzC,OAAO,gJAAY,CAAC,IAAI,CACtB;YAAE,OAAO;QAA2B,GACpC;YAAE,QAAQ;QAAI;IAElB;AACF"}}]
}